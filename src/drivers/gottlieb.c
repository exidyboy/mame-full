/***************************************************************************

Gottlieb driver : dedicated to Warren Davis, Jeff Lee & David Thiel

****************************************************************************

Reactor: earlier version of the board, with a different memory map

Main processor (8088 minimum mode)
0000-1fff RAM (NOT battery backed unlike all the others)
2000-2fff sprites
3000-37ff video ram
4000-4fff char generator ram
6000-67ff palette ram (palette of 16 colors)
7000-77ff i/o ports
8000-ffff ROM

memory mapped ports:

read:
7000    Dip switch
7001    Inputs 10-17
7002    trackball H
7003    trackball V
7004    Inputs 40-47

write:
7000    watchdog reset
7001    trackball clear
7002    Outputs 20-27
7003    Flipflop outputs:
		b0: F/B priority
		b1: horiz. flip
		b2: vert. flip
		b3: Output 33
		b4: coin counter
		b5: left lamp (1P/3Lives start)
		b6: middle lamps (2P/3Lives start, 1P/7Lives start)
		b7: right lamp (2P/7Lives start)
7004    Outputs 40-47

interrupts:
INTR not connected
NMI connected to vertical blank



Gottlieb games memory map

Main processor (8088 minimum mode)
0000-0fff RAM (battery backed)
1000-1fff RAM or ROM (selected with jumpers on the board)
2000-2fff RAM or ROM (selected with jumpers on the board)
3000-37ff sprites. The manual says there are 63 sprites (NOT 64),
          but the Q*Bert object priority test leaves sprite #63 dangling, so
		  they are probably only 62.
3800-3fff video RAM
4000-4fff char generator RAM (can be replaced by a ROM twice as large,
          selection made with jumpers on the board. If it's ROM, the CPU
		  cannot fully access it, I think it could read half the data if it
		  wanted to but none of the games do that)
5000-57ff palette ram (palette of 16 colors)
5800-5fff i/o ports
6000-ffff ROM (not necessarily fully populated)

memory mapped ports:

read:
5800    Dip switch
5801    Inputs 10-17
5802    trackball H (optional)
5803    trackball V (optional)
5804    Inputs 40-47

write:
5800    watchdog reset
5801    trackball clear (optional)
5802    Outputs 20-27
5803    Flipflop outputs:
		b0: F/B priority
		b1: horiz. flip (sprite bank in Us vs. Them)
		b2: vert. flip (maybe genlock control in the laser disc games)
		b3: Output 33
		b4: coin counter (sprite bank in Q*Bert Qubes)
		b5: Q*Bert: kicker; Q*Bert Qubes: coin counter
		b5/b6: 3 Stooges: joystick input multiplexer
		b7: ?
5804    Outputs 40-47

interrupts:
INTR not connected
NMI connected to vertical blank



Sound processor (6502) memory map (earlier revision, used by games up to Krull):
0000-0fff RIOT (6532)
1000-1fff amplitude DAC
2000-2fff SC01 voice chip
3000-3fff voice clock DAC
4000-4fff expansion socket
5000-5fff expansion socket
6000-6fff expansion socket or ROM (selected with jumpers on the board)
7000-7fff ROM
(repeated in 8000-ffff, A15 only used in expansion socket)

Use of I/Os on the RIOT:
both ports A and B are programmed as inputs, A is connected to the main
motherboard, and B has SW1 (test) connected on bit 6.

interrupts:
INTR is connected to the RIOT, so an INTR can be generated by a variety
of sources, e.g active edge detection on PA7, or timer countdown.
It seems that all gottlieb games program the interrupt conditions so that
a positive active edge on PA7 triggers an interrupt, so the
main board ensures a command is correctly received by sending nul (0)
commands between two commands. Also, the timer interrupt is enabled but
doesn't seem to serve any purpose...(?)


In the later revision of the sound board, used from M.A.C.H. 3 onwards, there
are two 6502, two 8910, a DAC and a different speech chip. The details of the
board are not known yet.


Video timings:
XTAL = 20 MHz
Horizontal video frequency: HSYNC = XTAL/4/318 = 15.72327 kHz
Video frequency: VSYNC = HSYNC/256 = 61.41903 Hz
VBlank duration: 1/VSYNC * (16/256) = 1017.6 us

***************************************************************************/

#include "driver.h"
#include "vidhrdw/generic.h"



int gottlieb_vh_start(void);
void gottlieb_vh_stop(void);
void gottlieb_characterram_w(int offset, int data);
void gottlieb_video_outputs(int offset,int data);
void usvsthem_video_outputs(int offset,int data);
extern unsigned char *gottlieb_characterram;
void gottlieb_paletteram_w(int offset,int data);
void gottlieb_vh_screenrefresh(struct osd_bitmap *bitmap,int full_refresh);

void gottlieb_sh_w(int offset, int data);

int riot_ram_r(int offset);
int gottlieb_riot_r(int offset);
void riot_ram_w(int offset, int data);
void gottlieb_riot_w(int offset, int data);
void gottlieb_speech_w(int offset, int data);
void gottlieb_speech_clock_DAC_w(int offset, int data);
int gottlieb_sh_init (const char *gamename);
int stooges_sound_input_r(int offset);
void stooges_8910_latch_w(int offset,int data);
void stooges_sound_control_w(int offset,int data);
void stooges_sound_timer_w(int offset,int data);

int gottlieb_nvram_load(void);
void gottlieb_nvram_save(void);



static int track[2];

int gottlieb_track_0_r(int offset)
{
	return input_port_2_r(offset) - track[0];
}

int gottlieb_track_1_r(int offset)
{
	return input_port_3_r(offset) - track[1];
}

void gottlieb_track_reset_w(int offset,int data)
{
	/* reset the trackball counters */
	track[0] = input_port_2_r(offset);
	track[1] = input_port_3_r(offset);
}

static int joympx;

int stooges_IN4_r(int offset)
{
	int joy;


	switch (joympx)
	{
		case 0:
		default:
			joy = ((readinputport(4) >> 0) & 0x0f);	/* joystick 1 */
			break;
		case 1:
			joy = ((readinputport(5) >> 0) & 0x0f);	/* joystick 2 */
			break;
		case 2:
			joy = ((readinputport(5) >> 4) & 0x0f);	/* joystick 3 */
			break;
	}

	return joy | (readinputport(4) & 0xf0);
}

void reactor_output(int offset,int data)
{
	osd_led_w(0,(data & 0x20) >> 5);
	osd_led_w(1,(data & 0x40) >> 6);
	osd_led_w(2,(data & 0x80) >> 7);
	gottlieb_video_outputs(offset,data);
}

void stooges_output(int offset,int data)
{
	joympx = (data >> 5) & 0x03;
	gottlieb_video_outputs(offset,data);
}


static int current_frame = 0x00001;
static int laserdisc_playing;
static int lasermpx;

int gottlieb_laserdisc_status_r(int offset)
{
	switch (offset)
	{
		case 0:
			return (current_frame >> 0) & 0xff;
			break;
		case 1:
			return (current_frame >> 8) & 0xff;
			break;
		case 2:
			if (lasermpx == 1)
				/* bits 0-2 frame number MSN */
				/* bit 3 audio buffer ready */
				/* bit 4 ready to send new laserdisc command? */
				/* bit 5 disc ready */
				/* bit 6 break in audio trasmission */
				/* bit 7 missing audio clock */
				return ((current_frame >> 16) & 0x07) | 0x10 | (rand() & 0x28);
			else	/* read audio buffer */
				return rand();
			break;
	}

	return 0;
}

void gottlieb_laserdisc_mpx_w(int offset,int data)
{
	lasermpx = data & 1;
}

void gottlieb_laserdisc_command_w(int offset,int data)
{
	static int loop;
	int cmd;
	static int lastcmd;


	/* commands are written in three steps, the first two the command is */
	/* written (maybe one to load the latch, the other to start the send), */
	/* the third 0 (maybe to clear the latch) */
	if (data == 0) return;
	if (loop++ & 1) return;

	if ((data & 0xe0) != 0x20)
	{
if (errorlog) fprintf(errorlog,"error: laserdisc command %02x\n",data);
		return;
	}

	cmd =	((data & 0x10) >> 4) |
			((data & 0x08) >> 2) |
			((data & 0x04) >> 0) |
			((data & 0x02) << 2) |
			((data & 0x01) << 4);

if (errorlog) fprintf(errorlog,"laserdisc command %02x -> %02x\n",data,cmd);
	if (lastcmd == 0x0b && (cmd & 0x10))	/* seek frame # */
	{
		current_frame = (current_frame << 4) | (cmd & 0x0f);
	}
	else
	{
		if (cmd == 0x04)	/* step forward */
		{
			laserdisc_playing = 0;
			current_frame++;
		}
		if (cmd == 0x05) laserdisc_playing = 1;	/* play */
		if (cmd == 0x0f) laserdisc_playing = 0;	/* stop */
		if (cmd == 0x0b) laserdisc_playing = 0;	/* seek frame */
		lastcmd = cmd;
	}
}

int gottlieb_interrupt(void)
{
	if (laserdisc_playing) current_frame++;

	return nmi_interrupt();
}



static struct MemoryReadAddress reactor_readmem[] =
{
	{ 0x0000, 0x1fff, MRA_RAM },
	{ 0x3000, 0x33ff, MRA_RAM },
	{ 0x4000, 0x4fff, MRA_RAM },
	{ 0x7000, 0x7000, input_port_0_r },	/* DSW */
	{ 0x7001, 0x7001, input_port_1_r },	/* buttons */
	{ 0x7002, 0x7002, gottlieb_track_0_r },	/* trackball H */
	{ 0x7003, 0x7003, gottlieb_track_1_r },	/* trackball V */
	{ 0x7004, 0x7004, input_port_4_r },	/* joystick */
	{ 0x8000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

static struct MemoryWriteAddress reactor_writemem[] =
{
	{ 0x0000, 0x1fff, MWA_RAM },
	{ 0x2000, 0x20ff, MWA_RAM, &spriteram, &spriteram_size },
	{ 0x3000, 0x33ff, videoram_w, &videoram, &videoram_size },
	{ 0x3400, 0x37ff, videoram_w },	/* mirror address, some games write to it */
	{ 0x4000, 0x4fff, gottlieb_characterram_w, &gottlieb_characterram },
	{ 0x6000, 0x601f, gottlieb_paletteram_w, &paletteram },
	{ 0x7000, 0x7000, watchdog_reset_w },
	{ 0x7001, 0x7001, gottlieb_track_reset_w },
	{ 0x7002, 0x7002, gottlieb_sh_w }, /* sound/speech command */
	{ 0x7003, 0x7003, reactor_output },       /* OUT1 */
	{ 0x8000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};

static struct MemoryReadAddress gottlieb_readmem[] =
{
	{ 0x0000, 0x0fff, MRA_RAM },
	{ 0x1000, 0x1fff, MRA_RAM },	/* or ROM */
	{ 0x2000, 0x2fff, MRA_RAM },	/* or ROM */
	{ 0x3800, 0x3bff, MRA_RAM },
	{ 0x4000, 0x4fff, MRA_RAM },
	{ 0x5800, 0x5800, input_port_0_r },	/* DSW */
	{ 0x5801, 0x5801, input_port_1_r },	/* buttons */
	{ 0x5802, 0x5802, gottlieb_track_0_r },	/* trackball H */
	{ 0x5803, 0x5803, gottlieb_track_1_r },	/* trackball V */
	{ 0x5804, 0x5804, input_port_4_r },	/* joystick */
	{ 0x5805, 0x5807, gottlieb_laserdisc_status_r },
	{ 0x6000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

static struct MemoryWriteAddress gottlieb_writemem[] =
{
	{ 0x0000, 0x0fff, MWA_RAM },
	{ 0x1000, 0x1fff, MWA_RAM },	/* ROM in Krull */
	{ 0x2000, 0x2fff, MWA_RAM },	/* ROM in Krull and 3 Stooges */
	{ 0x3000, 0x30ff, MWA_RAM, &spriteram, &spriteram_size },
	{ 0x3800, 0x3bff, videoram_w, &videoram, &videoram_size },
	{ 0x3c00, 0x3fff, videoram_w },	/* mirror address, some games write to it */
	{ 0x4000, 0x4fff, gottlieb_characterram_w, &gottlieb_characterram },
	{ 0x5000, 0x501f, gottlieb_paletteram_w, &paletteram },
	{ 0x5800, 0x5800, watchdog_reset_w },
	{ 0x5801, 0x5801, gottlieb_track_reset_w },
	{ 0x5802, 0x5802, gottlieb_sh_w }, /* sound/speech command */
	{ 0x5803, 0x5803, gottlieb_video_outputs },       /* OUT1 */
	{ 0x6000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};


/* same as above, different video_outputs plus laser disc control outputs */
static struct MemoryWriteAddress usvsthem_writemem[] =
{
	{ 0x0000, 0x0fff, MWA_RAM },
	{ 0x1000, 0x1fff, MWA_RAM },	/* ROM in Krull */
	{ 0x2000, 0x2fff, MWA_RAM },	/* ROM in Krull and 3 Stooges */
	{ 0x3000, 0x30ff, MWA_RAM, &spriteram, &spriteram_size },
	{ 0x3800, 0x3bff, videoram_w, &videoram, &videoram_size },
	{ 0x3c00, 0x3fff, videoram_w },	/* mirror address, some games write to it */
	{ 0x4000, 0x4fff, gottlieb_characterram_w, &gottlieb_characterram },
	{ 0x5000, 0x501f, gottlieb_paletteram_w, &paletteram },
	{ 0x5800, 0x5800, watchdog_reset_w },
	{ 0x5801, 0x5801, gottlieb_track_reset_w },
	{ 0x5802, 0x5802, gottlieb_sh_w }, /* sound/speech command */
	{ 0x5803, 0x5803, usvsthem_video_outputs },       /* OUT1 */
	{ 0x5805, 0x5805, gottlieb_laserdisc_command_w },	/* command for the player */
	{ 0x5806, 0x5806, gottlieb_laserdisc_mpx_w },
	{ 0x6000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};

/* same as above, different IN4 */
static struct MemoryReadAddress stooges_readmem[] =
{
	{ 0x0000, 0x0fff, MRA_RAM },
	{ 0x1000, 0x1fff, MRA_RAM },
	{ 0x2000, 0x2fff, MRA_ROM },
	{ 0x3800, 0x3bff, MRA_RAM },
	{ 0x4000, 0x4fff, MRA_RAM },
	{ 0x5800, 0x5800, input_port_0_r },	/* DSW */
	{ 0x5801, 0x5801, input_port_1_r },	/* buttons */
	{ 0x5802, 0x5802, gottlieb_track_0_r },	/* trackball H */
	{ 0x5803, 0x5803, gottlieb_track_1_r },	/* trackball V */
	{ 0x5804, 0x5804, stooges_IN4_r },	/* joystick */
	{ 0x6000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

/* same as above, different video_outputs */
static struct MemoryWriteAddress stooges_writemem[] =
{
	{ 0x0000, 0x0fff, MWA_RAM },
	{ 0x1000, 0x1fff, MWA_RAM },
	{ 0x2000, 0x2fff, MWA_ROM },
	{ 0x3000, 0x30ff, MWA_RAM, &spriteram, &spriteram_size },
	{ 0x3800, 0x3bff, videoram_w, &videoram, &videoram_size },
	{ 0x3c00, 0x3fff, videoram_w },	/* mirror address, some games write to it */
	{ 0x4000, 0x4fff, gottlieb_characterram_w, &gottlieb_characterram },
	{ 0x5000, 0x501f, gottlieb_paletteram_w, &paletteram },
	{ 0x5800, 0x5800, watchdog_reset_w },
	{ 0x5801, 0x5801, gottlieb_track_reset_w },
	{ 0x5802, 0x5802, gottlieb_sh_w }, /* sound/speech command */
	{ 0x5803, 0x5803, stooges_output },       /* OUT1 */
	{ 0x6000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};



struct MemoryReadAddress gottlieb_sound_readmem[] =
{
	{ 0x0000, 0x01ff, riot_ram_r },
	{ 0x0200, 0x03ff, gottlieb_riot_r },
	{ 0x6000, 0x7fff, MRA_ROM },
			 /* A15 not decoded except in expansion socket */
	{ 0x8000, 0x81ff, riot_ram_r },
	{ 0x8200, 0x83ff, gottlieb_riot_r },
	{ 0xe000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

struct MemoryWriteAddress gottlieb_sound_writemem[] =
{
	{ 0x0000, 0x01ff, riot_ram_w },
	{ 0x0200, 0x03ff, gottlieb_riot_w },
	{ 0x1000, 0x1000, DAC_data_w },
	{ 0x2000, 0x2000, gottlieb_speech_w },
	{ 0x3000, 0x3000, gottlieb_speech_clock_DAC_w },
	{ 0x6000, 0x7fff, MWA_ROM },
			 /* A15 not decoded except in expansion socket */
	{ 0x8000, 0x81ff, riot_ram_w },
	{ 0x8200, 0x83ff, gottlieb_riot_w },
	{ 0x9000, 0x9000, DAC_data_w },
	{ 0xa000, 0xa000, gottlieb_speech_w },
	{ 0xb000, 0xb000, gottlieb_speech_clock_DAC_w },
	{ 0xe000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};


static struct MemoryReadAddress stooges_sound_readmem[] =
{
	{ 0x0000, 0x03ff, MRA_RAM },
	{ 0x8000, 0x8000, soundlatch_r },
	{ 0xe000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

struct MemoryWriteAddress stooges_sound_writemem[] =
{
	{ 0x0000, 0x03ff, MWA_RAM },
	{ 0x4000, 0x4000, MWA_NOP },	/* DAC volume control (TODO: support it) */
	{ 0x4001, 0x4001, DAC_data_w },
	{ 0xe000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};


static struct MemoryReadAddress stooges_sound2_readmem[] =
{
	{ 0x0000, 0x03ff, MRA_RAM },
	{ 0x6000, 0x6000, stooges_sound_input_r },	/* various signals */
	{ 0xa800, 0xa800, soundlatch_r },
	{ 0xc000, 0xffff, MRA_ROM },
	{ -1 }  /* end of table */
};

struct MemoryWriteAddress stooges_sound2_writemem[] =
{
	{ 0x0000, 0x03ff, MWA_RAM },
	{ 0x2000, 0x2000, MWA_NOP },	/* speech chip. The game sends strings */
									/* of 15 bytes (clocked by 4000). The chip also */
									/* checks a ready bit in 6000. */
	{ 0x4000, 0x4000, stooges_sound_control_w },
	{ 0x8000, 0x8000, stooges_8910_latch_w },
	{ 0xa000, 0xa000, stooges_sound_timer_w },	/* the timer generates NMIs */
/*	{ 0xb000, 0xb000 } should generate a NMI on the first CPU, I think */
	{ 0xc000, 0xffff, MWA_ROM },
	{ -1 }  /* end of table */
};



INPUT_PORTS_START( reactor_input_ports )
	PORT_START	/* DSW */
	PORT_DIPNAME( 0x08, 0x08, "Sound with Instructions", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x08, "On" )
	PORT_DIPNAME( 0x01, 0x01, "Sound with Logos", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x01, "On" )
	PORT_DIPNAME( 0x10, 0x10, "Cabinet", IP_KEY_NONE )
	PORT_DIPSETTING(    0x10, "Upright" )
	PORT_DIPSETTING(    0x00, "Cocktail" )
	PORT_DIPNAME( 0x04, 0x04, "Free Play", IP_KEY_NONE )
	PORT_DIPSETTING(    0x04, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_DIPNAME( 0x20, 0x20, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "2 Coins/1 Credit" )
	PORT_DIPSETTING(    0x20, "1 Coin/1 Credit" )
	PORT_DIPNAME( 0x02, 0x02, "Bounce Chambers Points", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "10" )
	PORT_DIPSETTING(    0x02, "15" )
	PORT_DIPNAME( 0xc0, 0xc0, "Bonus Ship", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "10000" )
	PORT_DIPSETTING(    0x40, "12000" )
	PORT_DIPSETTING(    0xc0, "15000" )
	PORT_DIPSETTING(    0x80, "20000" )

	PORT_START	/* IN1 */
	PORT_BITX(0x01, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BITX(0x02, 0x02, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING (   0x02, "Off" )
	PORT_DIPSETTING (   0x00, "On" )
	PORT_BIT ( 0xfc, IP_ACTIVE_HIGH, IPT_UNKNOWN )

	PORT_START	/* trackball H */
	PORT_ANALOG ( 0xff, 0, IPT_TRACKBALL_X, 15, 0, 0, 0 )

	PORT_START	/* trackball V */
	PORT_ANALOG ( 0xff, 0, IPT_TRACKBALL_Y, 15, 0, 0, 0 )

	PORT_START	/* IN4 */
	PORT_BIT ( 0x01, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT ( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
	PORT_BIT ( 0x04, IP_ACTIVE_HIGH, IPT_BUTTON2 )
	PORT_BIT ( 0x08, IP_ACTIVE_HIGH, IPT_BUTTON1 )
	PORT_BIT ( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT ( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT ( 0xc0, IP_ACTIVE_HIGH, IPT_UNKNOWN )
INPUT_PORTS_END

INPUT_PORTS_START( mplanets_input_ports )
	PORT_START	/* DSW */
	PORT_DIPNAME( 0x08, 0x00, "Round Select", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x08, "On" )
	PORT_DIPNAME( 0x01, 0x00, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_DIPNAME( 0x14, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x04, "2 Coins/1 Credit" )
	PORT_DIPSETTING(    0x00, "1 Coin/1 Credit" )
	PORT_DIPSETTING(    0x10, "1 Coin/2 Credits" )
	PORT_DIPSETTING(    0x14, "Free Play" )
	PORT_DIPNAME( 0x20, 0x00, "Lives", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "3" )
	PORT_DIPSETTING(    0x20, "5" )
	PORT_DIPNAME( 0x02, 0x00, "Bonus Life", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "10000" )
	PORT_DIPSETTING(    0x02, "12000" )
	PORT_DIPNAME( 0xc0, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x40, "Easy" )
	PORT_DIPSETTING(    0x00, "Medium" )
	PORT_DIPSETTING(    0x80, "Hard" )
	PORT_DIPSETTING(    0xc0, "Hardest" )

	PORT_START	/* IN1 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x3c, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(0x40, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BITX( 0x80, 0x80, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING( 0x80, "Off" )
	PORT_DIPSETTING( 0x00, "On" )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V (dial) */
	PORT_ANALOGX( 0xff, 0x00, IPT_DIAL, 15, 0, 0, 0, OSD_KEY_Z, OSD_KEY_X, 0, 0, 4 )

	PORT_START	/* IN3 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START2 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_BUTTON2 )
INPUT_PORTS_END

INPUT_PORTS_START( qbert_input_ports )
	PORT_START      /* DSW */
	PORT_BITX( 0x08, 0x00, IPT_DIPSWITCH_NAME | IPF_CHEAT, "Auto Round Advance", IP_KEY_NONE, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x08, "On" )
	PORT_DIPNAME( 0x01, 0x00, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_DIPNAME( 0x10, 0x00, "Free Play", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x10, "On" )
	PORT_DIPNAME( 0x04, 0x00, "Cabinet", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Upright" )
	PORT_DIPSETTING(    0x04, "Cocktail" )
	PORT_DIPNAME( 0x20, 0x00, "SW5", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x20, "On" )
	PORT_DIPNAME( 0x02, 0x02, "Kicker", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x02, "On" )
	PORT_DIPNAME( 0x40, 0x00, "SW7", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x40, "On" )
	PORT_DIPNAME( 0x80, 0x00, "SW8", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x80, "On" )
	PORT_BIT( 0xe0, IP_ACTIVE_LOW, IPT_UNUSED )
/* 0x40 must be connected to the IP16 line */

	PORT_START      /* buttons */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(    0x40, 0x40, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING (   0x40, "Off" )
	PORT_DIPSETTING (   0x00, "On" )
	PORT_BITX(0x80, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* joystick */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_4WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_4WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_4WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY | IPF_COCKTAIL )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_4WAY | IPF_COCKTAIL )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_4WAY | IPF_COCKTAIL )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_4WAY | IPF_COCKTAIL )
INPUT_PORTS_END

INPUT_PORTS_START( qbertqub_input_ports )
	PORT_START      /* DSW */
	PORT_DIPNAME( 0x08, 0x00, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x08, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_DIPNAME( 0x35, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x24, "A 2/1 B 2/1" )
	PORT_DIPSETTING(    0x14, "A 1/1 B 4/1" )
	PORT_DIPSETTING(    0x30, "A 1/1 B 3/1" )
	PORT_DIPSETTING(    0x10, "A 1/1 B 2/1" )
	PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" )
	PORT_DIPSETTING(    0x11, "A 2/3 B 2/1" )
	PORT_DIPSETTING(    0x15, "A 1/2 B 3/1" )
	PORT_DIPSETTING(    0x20, "A 1/2 B 2/1" )
	PORT_DIPSETTING(    0x21, "A 1/2 B 1/1" )
	PORT_DIPSETTING(    0x31, "A 1/2 B 1/5" )
	PORT_DIPSETTING(    0x04, "A 1/3 B 2/1" )
	PORT_DIPSETTING(    0x05, "A 1/3 B 1/1" )
	PORT_DIPSETTING(    0x35, "Free Play" )
/* 0x25 "2 Coins/1 Credit"
   0x01 "1 Coin/1 Credit"
   0x34 "Free Play" */
	PORT_DIPNAME( 0x02, 0x00, "1st Bonus Life", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "10000" )
	PORT_DIPSETTING(    0x02, "15000" )
	PORT_DIPNAME( 0x40, 0x00, "Additional Bonus Life", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "20000" )
	PORT_DIPSETTING(    0x40, "25000" )
	PORT_DIPNAME( 0x80, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Normal" )
	PORT_DIPSETTING(    0x80, "Hard" )

	PORT_START      /* buttons */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START2 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(    0x40, 0x40, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING (   0x40, "Off" )
	PORT_DIPSETTING (   0x00, "On" )
	PORT_BITX(0x80, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* joystick */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_4WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_4WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_4WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_4WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
INPUT_PORTS_END

INPUT_PORTS_START( krull_input_ports )
	PORT_START      /* DSW0 */
	PORT_DIPNAME( 0x08, 0x00, "Lives", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "3" )
	PORT_DIPSETTING(    0x08, "5" )
	PORT_DIPNAME( 0x01, 0x00, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_DIPNAME( 0x14, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x04, "2 Coins/1 Credit" )
	PORT_DIPSETTING(    0x00, "1 Coin/1 Credit" )
	PORT_DIPSETTING(    0x10, "1 Coin/2 Credits" )
	PORT_DIPSETTING(    0x14, "Free play" )
	PORT_DIPNAME( 0x20, 0x00, "Hexagon", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Roving" )
	PORT_DIPSETTING(    0x20, "Stationary" )
	PORT_DIPNAME( 0x02, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Normal" )
	PORT_DIPSETTING(    0x02, "Hard" )
	PORT_DIPNAME( 0xc0, 0x00, "Bonus Life", IP_KEY_NONE )
	PORT_DIPSETTING(    0x40, "30000 30000" )
	PORT_DIPSETTING(    0x00, "30000 50000" )
	PORT_DIPSETTING(    0x80, "40000 50000" )
	PORT_DIPSETTING(    0xc0, "50000 75000" )

	PORT_START      /* IN0 */
	PORT_BITX(    0x01, 0x01, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* IN3 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_UP | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_RIGHT | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_DOWN | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICKLEFT_LEFT | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_UP | IPF_8WAY )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_RIGHT | IPF_8WAY )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_DOWN | IPF_8WAY )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICKRIGHT_LEFT | IPF_8WAY )
INPUT_PORTS_END

INPUT_PORTS_START( mach3_input_ports )
	PORT_START      /* DSW0 */
	/* TODO: values are different for 5 lives */
	PORT_DIPNAME( 0x09, 0x08, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x08, "2 Coins/1 Credit" )
	PORT_DIPSETTING(    0x01, "3 Coins/1 Credit" )
	PORT_DIPSETTING(    0x09, "4 Coins/1 Credit" )
	PORT_DIPSETTING(    0x00, "Free Play" )
	PORT_DIPNAME( 0x10, 0x00, "Lives", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "3" )
	PORT_DIPSETTING(    0x10, "5" )
	PORT_DIPNAME( 0x24, 0x00, "Bonus Life", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "10000 10000" )
	PORT_DIPSETTING(    0x04, "10000 20000" )
	PORT_DIPSETTING(    0x20, "10000 40000" )
	PORT_DIPSETTING(    0x24, "20000 60000" )
	PORT_DIPNAME( 0x02, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Normal" )
	PORT_DIPSETTING(    0x02, "Hard" )
	PORT_DIPNAME( 0x40, 0x40, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x40, "On" )
	PORT_BITX(    0x80, 0x80, IPT_DIPSWITCH_NAME | IPF_CHEAT, "Infinite Lives", IP_KEY_NONE, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x80, "On" )

	PORT_START      /* IN0 */
	PORT_BITX(    0x01, 0x01, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_TILT )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* IN3 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
INPUT_PORTS_END

INPUT_PORTS_START( usvsthem_input_ports )
	PORT_START      /* DSW0 */
	/* TODO: values are different for 5 lives */
	PORT_DIPNAME( 0x09, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "1 Coin/1 Credit" )
	PORT_DIPSETTING(    0x08, "2 Coins/1 Credit" )
	PORT_DIPSETTING(    0x01, "Free Play" )
/*	PORT_DIPSETTING(    0x09, "Free Play" ) */
	PORT_DIPNAME( 0x10, 0x00, "Unknown", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x10, "On" )
	PORT_DIPNAME( 0x04, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Normal" )
	PORT_DIPSETTING(    0x04, "Hard" )
	PORT_DIPNAME( 0x20, 0x00, "Unknown", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x20, "On" )
	PORT_DIPNAME( 0x02, 0x00, "Unknown", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x02, "On" )
	PORT_DIPNAME( 0x40, 0x00, "Unknown", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x40, "On" )
	PORT_DIPNAME( 0x80, 0x00, "Unknown", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x80, "On" )

	PORT_START      /* IN0 */
	PORT_BITX(    0x01, 0x01, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_TILT )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_START1 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_START2 )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* IN3 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON2 )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON3 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
INPUT_PORTS_END

INPUT_PORTS_START( stooges_input_ports )
	PORT_START	/* DSW */
	PORT_DIPNAME (0x08, 0x00, "Lives", IP_KEY_NONE )
	PORT_DIPSETTING (   0x00, "3" )
	PORT_DIPSETTING (   0x08, "5" )
	PORT_DIPNAME (0x01, 0x00, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING (   0x01, "Off" )
	PORT_DIPSETTING (   0x00, "On" )
	PORT_DIPNAME (0x14, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING (   0x04, "2 Coins/1 Credit" )
	PORT_DIPSETTING (   0x00, "1 Coin/1 Credit" )
	PORT_DIPSETTING (   0x10, "1 Coin/2 Credits" )
	PORT_DIPSETTING (   0x14, "Free Play" )
	PORT_DIPNAME( 0x20, 0x00, "SW5", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x20, "On" )
	PORT_DIPNAME (0x02, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING (   0x00, "Normal" )
	PORT_DIPSETTING (   0x02, "Hard" )
	PORT_DIPNAME (0x40, 0x00, "Bonus Life At", IP_KEY_NONE )
	PORT_DIPSETTING (   0x40, "10000" )
	PORT_DIPSETTING (   0x00, "20000" )
	PORT_DIPNAME (0x80, 0x00, "And Bonus Life Every", IP_KEY_NONE )
	PORT_DIPSETTING (   0x80, "10000" )
	PORT_DIPSETTING (   0x00, "20000" )

	PORT_START	/* IN1 */
	PORT_BITX(    0x01, 0x01, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING (   0x01, "Off" )
	PORT_DIPSETTING (   0x00, "On" )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_TILT )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* joystick 2 (Moe) */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_PLAYER2 | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER2 | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_PLAYER2 | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_PLAYER2 | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER2 )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER1 )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER3 )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )

	/* the bottom four bits of the previous port are multiplexed among */
	/* three joysticks - the following port contains settings for the other two */
	PORT_START
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_PLAYER3 | IPF_8WAY )
	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER3 | IPF_8WAY )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_PLAYER3 | IPF_8WAY )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_PLAYER3 | IPF_8WAY )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_JOYSTICK_UP | IPF_PLAYER1 | IPF_8WAY )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_JOYSTICK_RIGHT | IPF_PLAYER1 | IPF_8WAY )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_JOYSTICK_DOWN | IPF_PLAYER1 | IPF_8WAY )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_JOYSTICK_LEFT | IPF_PLAYER1 | IPF_8WAY )
INPUT_PORTS_END

INPUT_PORTS_START( curvebal_input_ports )
	PORT_START      /* DSW0 */
	PORT_DIPNAME( 0x08, 0x00, "2 Players Game", IP_KEY_NONE )
	PORT_DIPSETTING(    0x08, "1 Credit" )
	PORT_DIPSETTING(    0x00, "2 Credits" )
	PORT_DIPNAME( 0x11, 0x00, "Difficulty", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Easy" )
	PORT_DIPSETTING(    0x10, "Medium" )
	PORT_DIPSETTING(    0x01, "Hard" )
	PORT_DIPSETTING(    0x11, "Hardest" )
	PORT_DIPNAME( 0x04, 0x04, "Demo Sounds", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Off" )
	PORT_DIPSETTING(    0x04, "On" )
	PORT_DIPNAME( 0x20, 0x00, "Coins", IP_KEY_NONE )
	PORT_DIPSETTING(    0x00, "Normal" )
	PORT_DIPSETTING(    0x20, "French" )
	/* TODO: coinage is different when French is selected */
/* PORT_DIPNAME( 0xc2, 0x00, "French Coinage", IP_KEY_NONE )
PORT_DIPSETTING(    0x42, "A 3/1 B 1/2" )
PORT_DIPSETTING(    0x82, "A 1/5 B 1/2" )
PORT_DIPSETTING(    0x02, "A 2/1 B 2/3" )
PORT_DIPSETTING(    0xc0, "A 2/1 B 2/1" )
PORT_DIPSETTING(    0x80, "A 1/1 B 1/2" )
PORT_DIPSETTING(    0x40, "A 1/1 B 1/3" )
PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" )
PORT_DIPSETTING(    0xc2, "Free Play" ) */
	PORT_DIPNAME( 0xc2, 0x00, "Coinage", IP_KEY_NONE )
	PORT_DIPSETTING(    0x42, "A 4/1 B 1/1" )
	PORT_DIPSETTING(    0x82, "A 3/1 B 1/1" )
	PORT_DIPSETTING(    0x02, "A 2/1 B 1/1" )
	PORT_DIPSETTING(    0xc0, "A 2/1 B 2/1" )
	PORT_DIPSETTING(    0x80, "A 2/1 B 1/2" )
	PORT_DIPSETTING(    0x40, "A 2/1 B 1/3" )
	PORT_DIPSETTING(    0x00, "A 1/1 B 1/1" )
	PORT_DIPSETTING(    0xc2, "Free Play" )

	PORT_START      /* IN0 */
	PORT_BITX(    0x01, 0x01, IPT_DIPSWITCH_NAME | IPF_TOGGLE, "Service Mode", OSD_KEY_F2, IP_JOY_NONE, 0 )
	PORT_DIPSETTING(    0x01, "Off" )
	PORT_DIPSETTING(    0x00, "On" )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_SERVICE, "Select in Service Mode", OSD_KEY_F1, IP_JOY_NONE, 0 )
	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 )
	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )

	PORT_START	/* trackball H not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START	/* trackball V not used */
	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )

	PORT_START      /* IN3 */
	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(0x02, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER1, "Swing", IP_KEY_DEFAULT, IP_JOY_DEFAULT, 0)
	PORT_BITX(0x04, IP_ACTIVE_HIGH, IPT_BUTTON1 | IPF_PLAYER2, "Pitch Left", IP_KEY_DEFAULT, IP_JOY_DEFAULT, 0)
	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(0x10, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_PLAYER2, "Pitch Right", IP_KEY_DEFAULT, IP_JOY_DEFAULT, 0)
	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_UNKNOWN )
	PORT_BITX(0x40, IP_ACTIVE_HIGH, IPT_BUTTON2 | IPF_PLAYER1, "Bunt", IP_KEY_DEFAULT, IP_JOY_DEFAULT, 0)
	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_UNKNOWN )
INPUT_PORTS_END



/* the games can store char gfx data in either a 4k RAM area (128 chars), or */
/* a 8k ROM area (256 chars). */
static struct GfxLayout charRAMlayout =
{
	8,8,    /* 8*8 characters */
	128,    /* 128 characters */
	4,      /* 4 bits per pixel */
	{ 0, 1, 2, 3 },
	{ 0, 4, 8, 12, 16, 20, 24, 28},
	{ 0*32, 1*32, 2*32, 3*32, 4*32, 5*32, 6*32, 7*32 },
	32*8    /* every char takes 32 consecutive bytes */
};

static struct GfxLayout charROMlayout =
{
	8,8,    /* 8*8 characters */
	256,    /* 256 characters */
	4,      /* 4 bits per pixel */
	{ 0, 1, 2, 3 },
	{ 0, 4, 8, 12, 16, 20, 24, 28},
	{ 0*32, 1*32, 2*32, 3*32, 4*32, 5*32, 6*32, 7*32 },
	32*8    /* every char takes 32 consecutive bytes */
};

static struct GfxLayout spritelayout =
{
	16,16,  /* 16*16 sprites */
	256,    /* 256 sprites */
	4,      /* 4 bits per pixel */
	{ 0, 256*32*8, 2*256*32*8, 3*256*32*8 },
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0*16, 1*16, 2*16, 3*16, 4*16, 5*16, 6*16, 7*16,
			8*16, 9*16, 10*16, 11*16, 12*16, 13*16, 14*16, 15*16 },
	32*8    /* every sprite takes 32 consecutive bytes */
};

static struct GfxLayout qbertqub_spritelayout =
{
	16,16,  /* 16*16 sprites */
	512,    /* 512 sprites */
	4,      /* 4 bits per pixel */
	{ 0, 512*32*8, 2*512*32*8, 3*512*32*8 },
	{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
	{ 0*16, 1*16, 2*16, 3*16, 4*16, 5*16, 6*16, 7*16,
			8*16, 9*16, 10*16, 11*16, 12*16, 13*16, 14*16, 15*16 },
	32*8    /* every sprite takes 32 consecutive bytes */
};

static struct GfxDecodeInfo charRAM_gfxdecodeinfo[] =
{
	{ 0, 0x4000, &charRAMlayout, 0, 1 },	/* the game dynamically modifies this */
	{ 1, 0x0000, &spritelayout,  0, 1 },
	{ -1 } /* end of array */
};

static struct GfxDecodeInfo charROM_gfxdecodeinfo[] =
{
	{ 1, 0x0000, &charROMlayout, 0, 1 },
	{ 1, 0x2000, &spritelayout,  0, 1 },
	{ -1 } /* end of array */
};

static struct GfxDecodeInfo qbertqub_gfxdecodeinfo[] =
{
	{ 1, 0x0000, &charROMlayout,         0, 1 },
	{ 1, 0x2000, &qbertqub_spritelayout, 0, 1 },
	{ -1 } /* end of array */
};



static struct DACinterface dac_interface =
{
	1,
	441000,
	{ 255 },
	{ 0 },
};

static struct Samplesinterface samples_interface =
{
	1	/* one channel */
};

static struct AY8910interface ay8910_interface =
{
	2,	/* 2 chips */
	2000000,	/* 2 MHz */
	{ 255, 255 },
	{ 0 },
	{ 0 },
	{ 0 },
	{ 0 }
};



/********************************************************************
*
*  Machine Driver macro
*  ====================
*
*  There are two versions of the machine driver,
*  one for revision 1 sound board (1x6502 + DAC + Votrax),
*  one for revision 2 (2x6502 + DAC + GI speech chip + 2x8910).
*  They are identical apart form the sound CPU subsections.
*
********************************************************************/

#define MACHINE_DRIVER_SOUND_1(GAMENAME,READMEM,WRITEMEM,GFX)	\
static struct MachineDriver GAMENAME##_machine_driver =             \
{                                                                   \
	/* basic machine hardware */                                	\
	{		                                                        \
		{	  	                                                    \
			CPU_I86,												\
			5000000,        /* 5 Mhz */								\
			0,														\
			READMEM,WRITEMEM,0,0,									\
			gottlieb_interrupt,1									\
		},		                                                    \
		{		                                                    \
			CPU_M6502 | CPU_AUDIO_CPU ,								\
			3579545/4,	/* the board can be set to /2 as well */	\
			2,	/* memory region #2 */								\
			gottlieb_sound_readmem,gottlieb_sound_writemem,0,0,		\
			ignore_interrupt,1	/* IRQs are triggered by the main CPU */		\
								/* NMIs are triggered by the Votrax SC-01 */	\
		}                                                   		\
	},                                                          	\
	61, 1018,	/* frames per second, vblank duration */			\
	1,	/* 1 CPU slice per frame - interleaving is forced when a sound command is written */ \
	0,						                                    	\
																	\
	/* video hardware */                                        	\
	32*8, 32*8, { 0*8, 32*8-1, 0*8, 30*8-1 },						\
	GFX,                                                        	\
	16, 16,		                                                	\
	0,									                           	\
																	\
	VIDEO_TYPE_RASTER|VIDEO_SUPPORTS_DIRTY|VIDEO_MODIFIES_PALETTE,	\
	0,                                                          	\
	gottlieb_vh_start,												\
	gottlieb_vh_stop,												\
	gottlieb_vh_screenrefresh,										\
																	\
	/* sound hardware */                                        	\
	0,0,0,0,                                                    	\
	{                                                           	\
		{                                                   		\
			SOUND_DAC,												\
			&dac_interface											\
		},															\
		{															\
			SOUND_SAMPLES,	/* only for Q*Bert */					\
			&samples_interface										\
		}                                                   		\
	}                                                           	\
}

#define MACHINE_DRIVER_SOUND_2(GAMENAME,READMEM,WRITEMEM,GFX)	\
static struct MachineDriver GAMENAME##_machine_driver =             \
{                                                                   \
	/* basic machine hardware */                                	\
	{		                                                        \
		{	  	                                                    \
			CPU_I86,												\
			5000000,        /* 5 Mhz */								\
			0,														\
			READMEM,WRITEMEM,0,0,									\
			gottlieb_interrupt,1									\
		},		                                                    \
		{		                                                    \
			CPU_M6502 | CPU_AUDIO_CPU ,								\
			1000000,	/* 1 MHz */									\
			2,	/* memory region #2 */								\
			stooges_sound_readmem,stooges_sound_writemem,0,0,		\
			ignore_interrupt,1	/* IRQs are triggered by the main CPU */			\
								/* NMIs are triggered by the second sound CPU */	\
		},                                                   		\
		{		                                                    \
			CPU_M6502 | CPU_AUDIO_CPU ,								\
			1000000,	/* 1 MHz */									\
			3,	/* memory region #3 */								\
			stooges_sound2_readmem,stooges_sound2_writemem,0,0,		\
			ignore_interrupt,1	/* IRQs are triggered by the main CPU */			\
								/* NMIs are triggered by a programmable timer */	\
		}                                                   		\
	},                                                          	\
	61, 1018,	/* frames per second, vblank duration */			\
	1,	/* 1 CPU slice per frame - interleaving is forced when a sound command is written */ \
	0,						                                    	\
																	\
	/* video hardware */                                        	\
	32*8, 32*8, { 0*8, 32*8-1, 0*8, 30*8-1 },						\
	GFX,                                                        	\
	16, 16,		                                                	\
	0,									                           	\
																	\
	VIDEO_TYPE_RASTER|VIDEO_SUPPORTS_DIRTY|VIDEO_MODIFIES_PALETTE,	\
	0,                                                          	\
	gottlieb_vh_start,												\
	gottlieb_vh_stop,												\
	gottlieb_vh_screenrefresh,										\
																	\
	/* sound hardware */                                        	\
	gottlieb_sh_init,0,0,0,                                        	\
	{                                                           	\
		{                                                   		\
			SOUND_DAC,												\
			&dac_interface											\
		},															\
		{															\
			SOUND_AY8910,											\
			&ay8910_interface										\
		}                                                   		\
	}                                                           	\
}

/* games using the revision 1 sound board */
MACHINE_DRIVER_SOUND_1(reactor,reactor_readmem,reactor_writemem,charRAM_gfxdecodeinfo);
MACHINE_DRIVER_SOUND_1(gottlieb,gottlieb_readmem,gottlieb_writemem,charROM_gfxdecodeinfo);
MACHINE_DRIVER_SOUND_1(qbertqub,gottlieb_readmem,gottlieb_writemem,qbertqub_gfxdecodeinfo);
MACHINE_DRIVER_SOUND_1(krull,gottlieb_readmem,gottlieb_writemem,charRAM_gfxdecodeinfo);
/* games using the revision 2 sound board */
MACHINE_DRIVER_SOUND_2(mach3,gottlieb_readmem,usvsthem_writemem,charROM_gfxdecodeinfo);
MACHINE_DRIVER_SOUND_2(usvsthem,gottlieb_readmem,usvsthem_writemem,qbertqub_gfxdecodeinfo);
MACHINE_DRIVER_SOUND_2(stooges,stooges_readmem,stooges_writemem,charRAM_gfxdecodeinfo);


/***************************************************************************

  Game driver(s)

***************************************************************************/

ROM_START( reactor_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "ROM7", 0x8000, 0x1000, 0xd8f16275 )
	ROM_LOAD( "ROM6", 0x9000, 0x1000, 0x7aadbabf )
	ROM_LOAD( "ROM5", 0xa000, 0x1000, 0x9e2453f0 )
	ROM_LOAD( "ROM4", 0xb000, 0x1000, 0x2f1839e2 )
	ROM_LOAD( "ROM3", 0xc000, 0x1000, 0x70123534 )
	ROM_LOAD( "ROM2", 0xd000, 0x1000, 0xb50b26f3 )
	ROM_LOAD( "ROM1", 0xe000, 0x1000, 0xeaf1c223 )
	ROM_LOAD( "ROM0", 0xf000, 0x1000, 0xe126beca )

	ROM_REGION(0x8000)	/* temporary space for graphics (disposed after conversion) */
	/* 0000-0fff empty */
	ROM_LOAD( "FG0", 0x1000, 0x1000, 0x80076d89 )	/* sprites */
	/* 2000-2fff empty */
	ROM_LOAD( "FG1", 0x3000, 0x1000, 0x0577a58b )
	/* 4000-4fff empty */
	ROM_LOAD( "FG2", 0x5000, 0x1000, 0xe1ecaede )
	/* 6000-6fff empty */
	ROM_LOAD( "FG3", 0x7000, 0x1000, 0x50087b04 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "SND1", 0xf000, 0x800, 0x1367334b )
	ROM_RELOAD(       0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "SND2", 0xf800, 0x800, 0x10e64e0a )
	ROM_RELOAD(       0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( mplanets_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "ROM4", 0x6000, 0x2000, 0xf09b30bb )
	ROM_LOAD( "ROM3", 0x8000, 0x2000, 0x52223738 )
	ROM_LOAD( "ROM2", 0xa000, 0x2000, 0xe406bbb6 )
	ROM_LOAD( "ROM1", 0xc000, 0x2000, 0x385a7fa6 )
	ROM_LOAD( "ROM0", 0xe000, 0x2000, 0x29df430b )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "BG0", 0x0000, 0x1000, 0xb85b00c3 )	/* chars */
	ROM_LOAD( "BG1", 0x1000, 0x1000, 0x175bc547 )
	ROM_LOAD( "FG3", 0x2000, 0x2000, 0x7c6a72bc )	/* sprites */
	ROM_LOAD( "FG2", 0x4000, 0x2000, 0x6ab56cc7 )
	ROM_LOAD( "FG1", 0x6000, 0x2000, 0x16c596b7 )
	ROM_LOAD( "FG0", 0x8000, 0x2000, 0x96727f86 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "SND1", 0xf000, 0x800, 0xca36c072 )
	ROM_RELOAD(       0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "SND2", 0xf800, 0x800, 0x66461044 )
	ROM_RELOAD(       0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( qbert_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "qb-rom2.bin", 0xa000, 0x2000, 0xd1c1dad7 )
	ROM_LOAD( "qb-rom1.bin", 0xc000, 0x2000, 0xdc2bbad9 )
	ROM_LOAD( "qb-rom0.bin", 0xe000, 0x2000, 0xc23a8cfe )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "qb-bg0.bin", 0x0000, 0x1000, 0x035735a1 )	/* chars */
	ROM_LOAD( "qb-bg1.bin", 0x1000, 0x1000, 0xaac748c5 )
	ROM_LOAD( "qb-fg3.bin", 0x2000, 0x2000, 0x54bd5daf )	/* sprites */
	ROM_LOAD( "qb-fg2.bin", 0x4000, 0x2000, 0x200a62ae )
	ROM_LOAD( "qb-fg1.bin", 0x6000, 0x2000, 0x7a17df07 )
	ROM_LOAD( "qb-fg0.bin", 0x8000, 0x2000, 0x0ca72f4f )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "qb-snd1.bin", 0xf000, 0x800, 0x469952eb )
	ROM_RELOAD(              0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "qb-snd2.bin", 0xf800, 0x800, 0x200e1d22 )
	ROM_RELOAD(              0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( qbertjp_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "qbj-rom2.bin", 0xa000, 0x2000, 0x22b59259 )
	ROM_LOAD( "qbj-rom1.bin", 0xc000, 0x2000, 0xa9ffed43 )
	ROM_LOAD( "qbj-rom0.bin", 0xe000, 0x2000, 0xf20e301e )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "qb-bg0.bin", 0x0000, 0x1000, 0x035735a1 )	/* chars */
	ROM_LOAD( "qb-bg1.bin", 0x1000, 0x1000, 0xaac748c5 )
	ROM_LOAD( "qb-fg3.bin", 0x2000, 0x2000, 0x54bd5daf )	/* sprites */
	ROM_LOAD( "qb-fg2.bin", 0x4000, 0x2000, 0x200a62ae )
	ROM_LOAD( "qb-fg1.bin", 0x6000, 0x2000, 0x7a17df07 )
	ROM_LOAD( "qb-fg0.bin", 0x8000, 0x2000, 0x0ca72f4f )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "qb-snd1.bin", 0xf000, 0x800, 0x469952eb )
	ROM_RELOAD(              0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "qb-snd2.bin", 0xf800, 0x800, 0x200e1d22 )
	ROM_RELOAD(              0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( sqbert_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "qb-rom2.bin", 0xa000, 0x2000, 0xe4417b2b )
	ROM_LOAD( "qb-rom1.bin", 0xc000, 0x2000, 0x97ded634 )
	ROM_LOAD( "qb-rom0.bin", 0xe000, 0x2000, 0x15050cd5 )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "qb-bg0.bin", 0x0000, 0x1000, 0x3be1e889 )	/* chars */
	ROM_LOAD( "qb-bg1.bin", 0x1000, 0x1000, 0x0e5c8e52 )
	ROM_LOAD( "qb-fg3.bin", 0x2000, 0x2000, 0x6d4c679c )	/* sprites */
	ROM_LOAD( "qb-fg2.bin", 0x4000, 0x2000, 0x78869f58 )
	ROM_LOAD( "qb-fg1.bin", 0x6000, 0x2000, 0xb6cc7972 )
	ROM_LOAD( "qb-fg0.bin", 0x8000, 0x2000, 0xf7b7f189 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "qb-snd1.bin", 0xf000, 0x800, 0x469952eb )
	ROM_RELOAD(              0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "qb-snd2.bin", 0xf800, 0x800, 0x200e1d22 )
	ROM_RELOAD(              0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( qbertqub_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "qq-rom3.bin", 0x8000, 0x2000, 0xac3cb8e2 )
	ROM_LOAD( "qq-rom2.bin", 0xa000, 0x2000, 0x64167070 )
	ROM_LOAD( "qq-rom1.bin", 0xc000, 0x2000, 0xdc7d6dc1 )
	ROM_LOAD( "qq-rom0.bin", 0xe000, 0x2000, 0xf2bad75a )

	ROM_REGION(0x12000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "qq-bg0.bin", 0x0000, 0x1000, 0x13c600e6 )	/* chars */
	ROM_LOAD( "qq-bg1.bin", 0x1000, 0x1000, 0x542c9488 )
	ROM_LOAD( "qq-fg3.bin", 0x2000, 0x4000, 0xacd201f8 )	/* sprites */
	ROM_LOAD( "qq-fg2.bin", 0x6000, 0x4000, 0xa6a4660c )
	ROM_LOAD( "qq-fg1.bin", 0xa000, 0x4000, 0x038fc633 )
	ROM_LOAD( "qq-fg0.bin", 0xe000, 0x4000, 0x65b1f0f1 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "qb-snd1.bin", 0xf000, 0x800, 0x469952eb )
	ROM_RELOAD(              0x7000, 0x800) /* A15 is not decoded */
	ROM_LOAD( "qb-snd2.bin", 0xf800, 0x800, 0x200e1d22 )
	ROM_RELOAD(              0x7800, 0x800) /* A15 is not decoded */
ROM_END

ROM_START( krull_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "RAM2.BIN", 0x1000, 0x1000, 0x03fa87a8 )
	ROM_LOAD( "RAM4.BIN", 0x2000, 0x1000, 0x8d50227a )
	ROM_LOAD( "ROM4.BIN", 0x6000, 0x2000, 0x5e10647c )
	ROM_LOAD( "ROM3.BIN", 0x8000, 0x2000, 0xdda2011c )
	ROM_LOAD( "ROM2.BIN", 0xa000, 0x2000, 0x2ab22372 )
	ROM_LOAD( "ROM1.BIN", 0xc000, 0x2000, 0x5341023f )
	ROM_LOAD( "ROM0.BIN", 0xe000, 0x2000, 0x16e7bc1d )

	ROM_REGION(0x8000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "FG3.BIN", 0x0000, 0x2000, 0xf7bee74c )	/* sprites */
	ROM_LOAD( "FG2.BIN", 0x2000, 0x2000, 0xcf79bc05 )
	ROM_LOAD( "FG1.BIN", 0x4000, 0x2000, 0xf2f27094 )
	ROM_LOAD( "FG0.BIN", 0x6000, 0x2000, 0xdae82e5a )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "snd1.bin", 0xe000, 0x1000, 0x7390800c )
	ROM_RELOAD(0x6000, 0x1000) /* A15 is not decoded */
	ROM_LOAD( "snd2.bin", 0xf000, 0x1000, 0xe65ea116 )
	ROM_RELOAD(0x7000, 0x1000) /* A15 is not decoded */
ROM_END

ROM_START( mach3_rom )
	ROM_REGION(0x10000)	/* 64k for code */
	ROM_LOAD( "M3ROM4.BIN", 0x6000, 0x2000, 0x194f83f9 )
	ROM_LOAD( "M3ROM3.BIN", 0x8000, 0x2000, 0x59ac0e24 )
	ROM_LOAD( "M3ROM2.BIN", 0xa000, 0x2000, 0x04150291 )
	ROM_LOAD( "M3ROM1.BIN", 0xc000, 0x2000, 0xdccb6551 )
	ROM_LOAD( "M3ROM0.BIN", 0xe000, 0x2000, 0xf044e698 )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "MACH3BG0.BIN", 0x0000, 0x1000, 0xfe6435c0 )
	ROM_LOAD( "MACH3BG1.BIN", 0x1000, 0x1000, 0x4a264336 )
	ROM_LOAD( "MACH3FG3.BIN", 0x2000, 0x2000, 0x665d2bb7 )
	ROM_LOAD( "MACH3FG2.BIN", 0x4000, 0x2000, 0x861095d6 )
	ROM_LOAD( "MACH3FG1.BIN", 0x6000, 0x2000, 0x8bb34a6b )
	ROM_LOAD( "MACH3FG0.BIN", 0x8000, 0x2000, 0x9ab588af )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "M3DROM1.BIN", 0xf000, 0x1000, 0x38c85fce )

	ROM_REGION(0x10000)	/* 64k for second sound cpu */
	ROM_LOAD( "M3YROM1.BIN", 0xf000, 0x1000, 0x63f4c3a2 )
ROM_END

ROM_START( usvsthem_rom )
	ROM_REGION(0x10000)	/* 64k for code */
	ROM_LOAD( "USVS.RM4", 0x6000, 0x2000, 0x6a22ed88 )
	ROM_LOAD( "USVS.RM3", 0x8000, 0x2000, 0xc8f37c2b )
	ROM_LOAD( "USVS.RM2", 0xa000, 0x2000, 0x50a19c93 )
	ROM_LOAD( "USVS.RM1", 0xc000, 0x2000, 0xc7d6abda )
	ROM_LOAD( "USVS.RM0", 0xe000, 0x2000, 0xc35a57da )

	ROM_REGION(0x12000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "USVS.BG0", 0x0000, 0x1000, 0xb33ab5f0 )
	ROM_LOAD( "USVS.BG1", 0x1000, 0x1000, 0xe0d8c600 )
	ROM_LOAD( "USVS.FG3", 0x2000, 0x4000, 0x3c6f6455 )
	ROM_LOAD( "USVS.FG2", 0x6000, 0x4000, 0xb6d219a4 )
	ROM_LOAD( "USVS.FG1", 0xa000, 0x4000, 0x61b9c2b5 )
	ROM_LOAD( "USVS.FG0", 0xe000, 0x4000, 0x27beba12 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "USVSDROM.1", 0xe000, 0x2000, 0x9fb80d54 )

	ROM_REGION(0x10000)	/* 64k for second sound cpu */
	ROM_LOAD( "USVSYROM.1", 0xe000, 0x2000, 0x58c73a2f )
ROM_END

ROM_START( stooges_rom )
	ROM_REGION(0x10000)     /* 64k for code */
	ROM_LOAD( "GV113RAM.4", 0x2000, 0x1000, 0x64249570 )
	ROM_LOAD( "GV113ROM.4", 0x6000, 0x2000, 0x8fdb5ff5 )
	ROM_LOAD( "GV113ROM.3", 0x8000, 0x2000, 0x8d135dd7 )
	ROM_LOAD( "GV113ROM.2", 0xa000, 0x2000, 0x093ee71e )
	ROM_LOAD( "GV113ROM.1", 0xc000, 0x2000, 0x65319da1 )
	ROM_LOAD( "GV113ROM.0", 0xe000, 0x2000, 0x20f3727b )

	ROM_REGION(0x8000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "GV113FG3", 0x0000, 0x2000, 0xf3e09a2a )	/* sprites */
	ROM_LOAD( "GV113FG2", 0x2000, 0x2000, 0x5bde03f8 )
	ROM_LOAD( "GV113FG1", 0x4000, 0x2000, 0x3904746a )
	ROM_LOAD( "GV113FG0", 0x6000, 0x2000, 0xa2b57805 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "DROM1", 0xe000, 0x2000, 0x3aa5d107 )

	ROM_REGION(0x10000)	/* 64k for second sound cpu */
	ROM_LOAD( "YROM2", 0xc000, 0x2000, 0xae8c7f26 )
	ROM_LOAD( "YROM1", 0xe000, 0x2000, 0xf3bd9399 )
ROM_END

ROM_START( curvebal_rom )
	ROM_REGION(0x10000)	/* 64k for code */
	ROM_LOAD( "cb-rom-3.chp", 0x8000, 0x2000, 0x139d406d )
	ROM_LOAD( "cb-rom-2.chp", 0xa000, 0x2000, 0xb523573d )
	ROM_LOAD( "cb-rom-1.chp", 0xc000, 0x2000, 0x82b0f7d8 )
	ROM_LOAD( "cb-rom-0.chp", 0xe000, 0x2000, 0x2d9d1867 )

	ROM_REGION(0xa000)	/* temporary space for graphics (disposed after conversion) */
	ROM_LOAD( "cb-bg-0.chp", 0x0000, 0x1000, 0x2b3409b0 )
	ROM_LOAD( "cb-bg-1.chp", 0x1000, 0x1000, 0x50cb3569 )
	ROM_LOAD( "cb-fg-3.chp", 0x2000, 0x2000, 0x77ca2334 )
	ROM_LOAD( "cb-fg-2.chp", 0x4000, 0x2000, 0x6700be86 )
	ROM_LOAD( "cb-fg-1.chp", 0x6000, 0x2000, 0x90ba2ec8 )
	ROM_LOAD( "cb-fg-0.chp", 0x8000, 0x2000, 0x112e7ee6 )

	ROM_REGION(0x10000)	/* 64k for sound cpu */
	ROM_LOAD( "yrom.sbd", 0xe000, 0x1000, 0x6066d74a )
	ROM_LOAD( "drom.sbd", 0xf000, 0x1000, 0x607b0ee3 )
ROM_END



static const char *qbert_sample_names[] =
{
	"*qbert",
	"FX_18.SAM", /*curse*/
	"FX_20.SAM", /*little purple guy*/
	"fx_22.sam", /*snake falling */
	"fx_17.sam", /*green guy*/
     0	/* end of array */
};



/* Reactor is the only game which doesn't have non volatile RAM */
static int reactor_hiload(void)
{
	unsigned char *RAM = Machine->memory_region[Machine->drv->cpu[0].memory_region];


	/* check if the hi score table has already been initialized */
	if (memcmp(&RAM[0x04e3],"\x01\x00\x00\x00",4) == 0 &&
			memcmp(&RAM[0x0554],"\x03\x00\x00",3) == 0 &&
			memcmp(&RAM[0x05c7],"\x02\x00\x00\x00",4) == 0 &&
			memcmp(&RAM[0x0638],"\x06\x00\x00",3) == 0)
	{
		void *f;


		if ((f = osd_fopen(Machine->gamedrv->name,0,OSD_FILETYPE_HIGHSCORE,0)) != 0)
		{
			osd_fread(f,&RAM[0x04d8],16*8);	/* 3 lives */
			osd_fread(f,&RAM[0x05bc],16*8);	/* 7 lives */

			osd_fclose(f);
		}

		return 1;
	}
	else return 0;	/* we can't load the hi scores yet */
}

static void reactor_hisave(void)
{
	void *f;
	unsigned char *RAM = Machine->memory_region[Machine->drv->cpu[0].memory_region];


	if ((f = osd_fopen(Machine->gamedrv->name,0,OSD_FILETYPE_HIGHSCORE,1)) != 0)
	{
		osd_fwrite(f,&RAM[0x04d8],16*8);	/* 3 lives */
		osd_fwrite(f,&RAM[0x05bc],16*8);	/* 7 lives */
		osd_fclose(f);
	}
}


int gottlieb_nvram_load(void)
{
	void *f;
	unsigned char *RAM = Machine->memory_region[Machine->drv->cpu[0].memory_region];


	/* Try loading static RAM */
	if ((f = osd_fopen(Machine->gamedrv->name,0,OSD_FILETYPE_HIGHSCORE,0)) != 0)
	{
		/* just load in everything, the game will overwrite what it doesn't want */
		osd_fread(f,&RAM[0x0000],0x1000);
		osd_fclose(f);
	}
	/* Invalidate the static RAM to force reset to factory settings */
	else memset(&RAM[0x0000],0xff,0x1000);

	return 1;
}

void gottlieb_nvram_save(void)
{
	void *f;
	unsigned char *RAM = Machine->memory_region[Machine->drv->cpu[0].memory_region];


	if ((f = osd_fopen(Machine->gamedrv->name,0,OSD_FILETYPE_HIGHSCORE,1)) != 0)
	{
		osd_fwrite(f,&RAM[0x0000],0x1000);
		osd_fclose(f);
	}
}


struct GameDriver reactor_driver =
{
	__FILE__,
	0,
	"reactor",
	"Reactor",
	"1982",
	"Gottlieb",
	"Fabrice Frances",
	0,
	&reactor_machine_driver,

	reactor_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	reactor_input_ports,

	0, 0, 0,
	ORIENTATION_DEFAULT,

	reactor_hiload, reactor_hisave     /* hi-score load and save */
};

struct GameDriver mplanets_driver =
{
	__FILE__,
	0,
	"mplanets",
	"Mad Planets",
	"1983",
	"Gottlieb",
	"Fabrice Frances",
	0,
	&gottlieb_machine_driver,

	mplanets_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	mplanets_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver qbert_driver =
{
	__FILE__,
	0,
	"qbert",
	"Q*Bert (US)",
	"1982",
	"Gottlieb",
	"Fabrice Frances (MAME driver)\nMarco Cassili\nJohn Butler     (speech\nHowie Cohen     samples)\n\nDedicated to:\nWarren Davis\nJeff Lee\nDavid Thiel",
	0,
	&gottlieb_machine_driver,

	qbert_rom,
	0, 0,
	qbert_sample_names,
	0,	/* sound_prom */

	qbert_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver qbertjp_driver =
{
	__FILE__,
	&qbert_driver,
	"qbertjp",
	"Q*Bert (Japan)",
	"1982",
	"Gottlieb (Konami license)",
	"Fabrice Frances (MAME driver)\nMarco Cassili\nJohn Butler     (speech\nHowie Cohen     samples)\n\nDedicated to:\nWarren Davis\nJeff Lee\nDavid Thiel",
	0,
	&gottlieb_machine_driver,

	qbertjp_rom,
	0, 0,
	qbert_sample_names,
	0,	/* sound_prom */

	qbert_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver sqbert_driver =
{
	__FILE__,
	0,
	"sqbert",
	"FHMC Q*Bert",
	"1983",
	"Mylstar",
	"Fabrice Frances (MAME driver)\nMarco Cassili\nJohn Butler     (speech\nHowie Cohen     samples)\n\n Special thanks to:\nFred Sookiasian\n\nDedicated to:\nWarren Davis\nJeff Lee\nDavid Thiel",
	0,
	&gottlieb_machine_driver,

	sqbert_rom,
	0, 0,
	qbert_sample_names,
	0,	/* sound_prom */

	qbert_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver qbertqub_driver =
{
	__FILE__,
	0,
	"qbertqub",
	"Q*Bert Qubes",
	"1983",
	"Mylstar",
	"Fabrice Frances & Rodimus Prime (MAME driver)\nMarco Cassili",
	0,
	&qbertqub_machine_driver,

	qbertqub_rom,
	0, 0,
	qbert_sample_names,
	0,	/* sound_prom */

	qbertqub_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver krull_driver =
{
	__FILE__,
	0,
	"krull",
	"Krull",
	"1983",
	"Gottlieb",
	"Fabrice Frances (MAME driver)\nMarco Cassili",
	0,
	&krull_machine_driver,

	krull_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	krull_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver mach3_driver =
{
	__FILE__,
	0,
	"mach3",
	"M.A.C.H. 3",
	"1983",
	"Mylstar",
	"Fabrice Frances (MAME driver)\n\n"
	"This is a LASER DISC game, so it doesn't work.",
	GAME_NOT_WORKING,
	&mach3_machine_driver,

	mach3_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	mach3_input_ports,

	0, 0, 0,
	ORIENTATION_DEFAULT,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver usvsthem_driver =
{
	__FILE__,
	0,
	"usvsthem",
	"Us vs. Them",
	"????",
	"Mylstar",
	"Fabrice Frances (MAME driver)\n\n"
	"This is a LASER DISC game, so it doesn't work.",
	GAME_NOT_WORKING,
	&usvsthem_machine_driver,

	usvsthem_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	usvsthem_input_ports,

	0, 0, 0,
	ORIENTATION_DEFAULT,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver stooges_driver =
{
	__FILE__,
	0,
	"3stooges",
	"Three Stooges",
	"1984",
	"Mylstar",
	"Fabrice Frances (MAME driver)\nJohn Butler\nMarco Cassili",
	0,
	&stooges_machine_driver,

	stooges_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	stooges_input_ports,

	0, 0, 0,
	ORIENTATION_DEFAULT,

	gottlieb_nvram_load, gottlieb_nvram_save
};

struct GameDriver curvebal_driver =
{
	__FILE__,
	0,
	"curvebal",
	"Curve Ball",
	"1984",
	"Mylstar",
	"Fabrice Frances (MAME driver)",
	0,
	&gottlieb_machine_driver,

	curvebal_rom,
	0, 0,
	0,
	0,	/* sound_prom */

	curvebal_input_ports,

	0, 0, 0,
	ORIENTATION_ROTATE_270,

	gottlieb_nvram_load, gottlieb_nvram_save
};
